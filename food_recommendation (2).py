# -*- coding: utf-8 -*-
"""food recommendation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TMpfPznX6VFi7nVwgLtLNU1D70eOYY3o
"""

import streamlit as st
import pandas as pd
import requests
from groq import Groq
import os
from fuzzywuzzy import process,fuzz

GROQ_API_KEY = "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"

# Initialize Groq API
client = Groq(api_key=GROQ_API_KEY)
# Helper to load Lottie animations
# Load dataset
menu_df = pd.read_csv('C:\\Users\\Ankan\\Downloads\\corrected_menu_dataset.csv')

# Groq translation function
def translate_with_groq(user_query, target_language="en"):
    """
    Use Groq API to translate user query to the target language (default is English).
    """
    try:
        chat_completion = client.chat.completions.create(
            messages=[
                {
                    "role": "user",
                    "content": f"Translate this to {target_language}: {user_query}",
                }
            ],
            model="llama3-8b-8192",
        )
        return chat_completion.choices[0].message.content.strip()
    except Exception as e:
        st.error(f"Translation failed: {e}")
        return None


# Keyword mapping for precise type extraction
types = {
    "peene": "Beverage",
    "drink": "Beverage",
    "drinks": "Beverage",
    "beverage": "Beverage",
    "beverages": "Beverage",
    "juice": "Beverage",
    "coffee": "Beverage",
    "tea": "Beverage",
    "milkshake": "Milkshake",
    "khane": "Main Course",
    "food": "Main Course",
    "dinner": "Main Course",
    "lunch": "Main Course",
    "meal": "Main Course",
    "biriyani": "Main Course",
    "curry": "Main Course",
    "snack": "Snack",
    "snacks": "Snack",
    "fast food": "Snack",
    "pakoda": "Snack",
    "fries": "Snack",
    "chips": "Snack",
    "starter": "Snack",
    "appetizer": "Snack",
    "meethe": "Dessert",
    "dessert": "Dessert",
    "sweet": "Dessert",
    "sweets": "Dessert",
    "cake": "Dessert",
    "pastry": "Dessert",
    "ice cream": "Dessert",
    "chocolate": "Dessert",
    "brownie": "Dessert",
    "sweet": "Dessert",
    "meetha": "Dessert",
    "halwa": "Dessert",
    "mexican": "Mexican",
    "indian": "Indian",
    "american": "American",
    "italian": "Italian",
    "chinese": "Chinese",
}

stopwords = {"bhi", "hai", "kya", "ka"}  # Add any other non-relevant words here

def preprocess_query(query):
    """
    Remove stopwords and unnecessary words from the query.
    """
    words = query.lower().split()
    return " ".join(word for word in words if word not in stopwords)

# Extract preferences from user query
def extract_preferences(user_query):
    preferences = {"type": None, "budget": None, "cuisine": None, "search_term": None}
    words = user_query.lower().split()

    for word in words:
        if word.isdigit():
            preferences["budget"] = int(word)
        elif word in types:
            if types[word] in ["Mexican", "Indian", "American", "Italian", "Chinese"]:
                preferences["cuisine"] = types[word]
            else:
                preferences["type"] = types[word]
        else:
            # Treat any unmatched word as a potential search term
            preferences["search_term"] = word
    return preferences



# Filter menu based on preferences
def recommend_food(preferences):
    filtered_menu = menu_df.copy()

    # Extract user preferences
    search_term = preferences.get("search_term") or preferences.get("type")
    budget = preferences.get("budget")
    filtered_menu["Item Name"] = filtered_menu["Item Name"].str.lower()  # Ensure consistent case

    # Debugging Output (Print preferences)
    print("Preferences:", preferences)

    # Step 1: Filter exact matches
    if search_term:
        exact_matches = filtered_menu[
            filtered_menu["Item Name"].str.contains(rf"\b{search_term.lower()}\b", case=False, na=False)
        ]
        print("Exact Matches:", exact_matches)  # Debugging Output

        if budget:
            exact_matches = exact_matches[exact_matches["Price"] <= budget]
        if not exact_matches.empty:
            exact_matches["Discount"] = (
                exact_matches["Discount"].str.replace("% off", "", regex=False).astype(float)
            )
            return exact_matches.sort_values(
                by=["Rating", "Discount", "Price"], ascending=[False, False, True]
            )[["Item Name", "Price", "Type", "Cuisine", "Rating", "Discount"]]

    # Step 2: Fuzzy matching if no exact matches
    if search_term:
        menu_items = filtered_menu["Item Name"].dropna().tolist()
        fuzzy_matches = process.extract(search_term, menu_items, limit=10, scorer=fuzz.partial_ratio)
        print("Fuzzy Matches:", fuzzy_matches)  # Debugging Output

        fuzzy_items = [match[0] for match in fuzzy_matches if match[1] > 85]  # Adjust threshold if needed
        fuzzy_filtered = filtered_menu[filtered_menu["Item Name"].isin(fuzzy_items)]
        if budget:
            fuzzy_filtered = fuzzy_filtered[fuzzy_filtered["Price"] <= budget]
        if not fuzzy_filtered.empty:
            fuzzy_filtered["Discount"] = (
                fuzzy_filtered["Discount"].str.replace("% off", "", regex=False).astype(float)
            )
            return fuzzy_filtered.sort_values(
                by=["Rating", "Discount", "Price"], ascending=[False, False, True]
            )[["Item Name", "Price", "Type", "Cuisine", "Rating", "Discount"]]

    # Step 3: Broader filtering based on other preferences
    if preferences["cuisine"]:
        filtered_menu = filtered_menu[
            filtered_menu["Cuisine"].str.contains(preferences["cuisine"], case=False, na=False)
        ]
    if preferences["type"]:
        filtered_menu = filtered_menu[
            filtered_menu["Type"].str.contains(preferences["type"], case=False, na=False)
        ]
    if budget:
        filtered_menu = filtered_menu[filtered_menu["Price"] <= budget]

    if not filtered_menu.empty:
        filtered_menu["Discount"] = (
            filtered_menu["Discount"].str.replace("% off", "", regex=False).astype(float)
        )
        return filtered_menu.sort_values(
            by=["Rating", "Discount", "Price"], ascending=[False, False, True]
        )[["Item Name", "Price", "Type", "Cuisine", "Rating", "Discount"]]
    else:
        return "No matches found! Please adjust your preferences."


# Callback to handle cart updates
def add_to_cart_and_show_next(item_name, item_price, preferences):
    """
    Add an item to the cart and display the next available item matching the preferences and remaining budget.
    """
    # Add the item to the cart
    if item_price <= st.session_state.remaining_budget:
        st.session_state.cart.append({"Item Name": item_name, "Price": item_price})
        st.session_state.remaining_budget -= item_price
        st.success(f"{item_name} added to your cart!")

        # Show next available item
        next_recommendations = recommend_food(preferences)
        if isinstance(next_recommendations, pd.DataFrame) and not next_recommendations.empty:
            next_recommendations = next_recommendations[
                next_recommendations["Price"] <= st.session_state.remaining_budget
            ]
            if not next_recommendations.empty:
                st.subheader("Next Matching Item üç¥")
                row = next_recommendations.iloc[0]  # Show the first matching item
                st.markdown(f"""
                    <div class="recommendation-card">
                        <div class="recommendation-header">{row['Item Name']}</div>
                        <div class="recommendation-details">
                            Cuisine: {row['Cuisine']} | Type: {row['Type']} | Rating: ‚≠ê{row['Rating']}
                        </div>
                        <div class="recommendation-price">Price: ‚Çπ{row['Price']} | Discount: {row['Discount']}%</div>
                    </div>
                """, unsafe_allow_html=True)
            else:
                st.info("No more items match your preferences and remaining budget.")
        else:
            st.info("No more items match your preferences and remaining budget.")
    else:
        st.warning(f"Not enough budget to add {item_name}.")

# Streamlit UI Configuration
st.set_page_config(
    page_title="Guli - Food Recommendations",
    layout="wide",
)

# Initialize session state
if "cart" not in st.session_state:
    st.session_state["cart"] = []
if "remaining_budget" not in st.session_state:
    st.session_state["remaining_budget"] = None  # Set dynamically based on user query
if "chat_history" not in st.session_state:
    st.session_state["chat_history"] = []

# Custom CSS for UI
st.markdown("""
    <style>
        /* General Body Style */
        body {
            font-family: "Poppins", sans-serif;
            background-color: #f8f9fa;
        }

        /* Title Section */
        .title {
            font-size: 48px;
            font-weight: bold;
            color: #fc8019;
            text-align: center;
            margin-bottom: 10px;
        }
        .subtitle {
            font-size: 20px;
            color: #555555;
            text-align: center;
            margin-bottom: 30px;
        }

        /* Recommendation Card Style */
        .recommendation-card {
            background: linear-gradient(135deg, #ffffff 60%, #fcf6ec);
            border-radius: 15px;
            padding: 20px;
            margin: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .recommendation-card:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        .recommendation-header {
            font-size: 22px;
            font-weight: bold;
            color: #333333;
            margin-bottom: 8px;
        }
        .recommendation-details {
            font-size: 16px;
            color: #666666;
            margin: 5px 0;
        }
        .recommendation-price {
            font-size: 18px;
            font-weight: bold;
            color: #28a745;
            margin-top: 10px;
        }

        /* Sidebar Cart Style */
        .sidebar-cart-header {
            font-size: 24px;
            font-weight: bold;
            color: #fc8019;
            margin-bottom: 20px;
            text-align: center;
        }
        .cart-item {
            background: #ffffff;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .cart-item:hover {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .remaining-budget {
            font-size: 18px;
            font-weight: bold;
            color: #28a745;
            margin-top: 20px;
        }

        /* Buttons */
        button {
            background-color: #fc8019;
            color: white;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        button:hover {
            background-color: #e06900;
        }
    </style>
""", unsafe_allow_html=True)


# Title Section
st.markdown('<div class="title">üçΩÔ∏è Welcome to Guli</div>', unsafe_allow_html=True)
st.markdown('<div class="subtitle">Your personalized food guide awaits!</div>', unsafe_allow_html=True)

# User Query Input
query = st.text_input("Feeling hungry? Describe your mood (e.g., 'I want Mexican food under 200')")

# Extract preferences and update initial budget
if query:
    preferences = extract_preferences(query)
    if preferences["budget"] and st.session_state["remaining_budget"] is None:
        st.session_state["remaining_budget"] = preferences["budget"]

# Recommendations Button
if st.button("Find My Dish"):
    if query.strip():
        with st.spinner("Cooking up your recommendations..."):
            preferences = extract_preferences(query)
            recommendations = recommend_food(preferences)

            if isinstance(recommendations, pd.DataFrame):
                st.subheader("Recommended Dishes üç¥")
                for idx, row in recommendations.iterrows():
                    st.markdown(f"""
                        <div class="recommendation-card">
                            <div class="recommendation-header">{row['Item Name']}</div>
                            <div class="recommendation-details">
                                Cuisine: {row['Cuisine']} | Type: {row['Type']} | Rating: ‚≠ê{row['Rating']}
                            </div>
                            <div class="recommendation-price">Price: ‚Çπ{row['Price']} | Discount: {row['Discount']}%</div>
                        </div>
                    """, unsafe_allow_html=True)
                    if st.button(
                        f"Add {row['Item Name']} (‚Çπ{row['Price']}) to Cart",
                        key=f"{row['Item Name']}-{idx}",
                        on_click=add_to_cart_and_show_next,
                        args=(row["Item Name"], row["Price"], preferences),
                    ):
                        pass
            else:
                st.warning(recommendations)
    else:
        st.error("Please describe your preferences!")


# Display Cart
st.sidebar.header("üõí Your Cart")
if st.session_state["cart"]:
    for item in st.session_state["cart"]:
        st.sidebar.write(f"{item['Item Name']} - ‚Çπ{item['Price']}")
    st.sidebar.write(f"Remaining Budget: ‚Çπ{st.session_state['remaining_budget']}")
    if st.sidebar.button("Clear Cart"):
        st.session_state["cart"] = []
        st.session_state["remaining_budget"] = None  # Reset to dynamic
else:
    st.sidebar.write("Your cart is empty. Add some items!")

